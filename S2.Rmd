---
title: "S2 Appendix"
output:
  pdf_document: 
    number_sections: true
header-includes:
  - \usepackage{booktabs}
---

This appendix aims to illustrate the inference process applied to DGP3. This
structure consists of nine candidate deterministic process models (PM3) and an
observational or measurement model (OM2) that accounts for the daily COVID-19 
cases detected in Ireland's first wave. We envision this inference process in a
Bayesian context, where the predicted values stem from DGP3's expected value,
which is approximated using Hamiltonian Monte Carlo (HMC).

\tableofcontents 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)

library(cmdstanr)
library(dplyr)
library(extraDistr)
library(imputeTS)
library(kableExtra)
library(lubridate)
library(Metrics)
library(purrr)
library(readr)
library(readsdr)
library(readxl)
library(rstan)
library(stringr)
library(tictoc)
library(tidyr)

source("./R_scripts/helpers.R")
folder      <- "./Saved_objects/Irish_data/SEI3R_SMTH"
stan_folder <- "./Stan_files"
```

\newpage

# Data

For this inference process, we use two datasets. In the first step, we fit via 
HMC the nine candidate models to the incidence data. Then, we compare the 
estimated relative contact rates to the normalised driving indexes.

\hfill

```{r}
source("./R_scripts/irish_data.R")
irish_data   <- get_irish_data()

source("./R_scripts/apple.R")
drv_data_obj <- get_driving_data()
imp          <- drv_data_obj$imputed_data
dates        <- seq(ymd('2020-02-29'), ymd("2020-05-17"), by = '1 day')
daily_mob_df <- data.frame(date = dates, y = imp)
```

```{r, fig.height = 6}
source("./R_scripts/plots.R")

plot_daily_data(irish_data, daily_mob_df)
```

\newpage

# DGP3 - Adaptive expectations

## Process model (PM3)

\begin{equation}
    \frac{dS}{dt} = - S_t \lambda_t
\end{equation}

\begin{equation}
   \frac{dE}{dt} = S_t \lambda_t - \sigma E_t
\end{equation}

\begin{equation}
   \frac{dP}{dt} = \omega \sigma E_t - \eta P_t
\end{equation}

\begin{equation}
   \frac{dI}{dt} =  \eta P_t - \gamma I_t
\end{equation}

\begin{equation}
   \frac{dA}{dt} =  (1-\omega) \sigma E_t - \kappa A_t
\end{equation}

\begin{equation}
   \frac{dR}{dt} =  \kappa A_t - \gamma I_t
\end{equation}

\begin{equation}
   \lambda_t =  \frac{ \beta_t(I(_t + P_t + \mu A_t)}{N_t} 
\end{equation}

\begin{equation}
   \beta_t = \zeta Z^1_t
\end{equation}

\begin{equation}
  \frac{dZ^i}{dt} = \begin{cases}
    \frac{(\upsilon - Z^i_t)}{(\nu^{-1}/n)} \quad i = 1\\ 
    \\
    \frac{(Z^{i-1}_t - Z^i_t)}{(\nu^{-1}/n)} \quad \textrm{for} \quad i \in (2, \dotsc, n)   \end{cases}
\end{equation}

\begin{equation}
   \frac{dC^d}{dt} =  \eta P_t - C^d_t\delta(t \, mod \, 1)
\end{equation}

## Measurement model (OM2)

\begin{equation}
  y_3\sim Pois(C^d_t) 
\end{equation}

\newpage

# Inference

## Priors

For all of the nine candidate modes, we adopt the following priors:

\hfill

```{r, fig.height = 5}
source("./R_scripts/plots.R")
plot_priors()
```

```{r inference_lists}
source("./R_scripts/stan_utils.R")
source("./R_scripts/write_SEI3R_model.R")
n_orders            <- 9
posterior_list      <- vector("list", n_orders)
sim_incidences_list <- vector("list", n_orders)
Z_list              <- vector("list", n_orders)
ll_list             <- vector("list", n_orders)
time_list           <- vector("list", n_orders)
```

## Sampling


For validation purposes, we show the results from the sampling procedure (HMC)
by means of trace plots. These visualisation tools are time-series of the draws
for a particular parameter. Here, _time_ refers to the order in which the draws 
were sampled. Furthermore, the reader can find the diagnostics for each 
calibration run in the repository of this work. There, we can notice that no 
_pathological behaviour_ was observed during the target (posterior) distribution exploration, in addition to adequate Effective Sample Sizes and potential scale
reduction factors ($\widehat{R} < 1.01$). These outcomes suggest that the Markov
chains converged to the posterior distribution.

### 1st order delay

```{r}
dly_o <- 1 # delay order

mdl_path  <- str_glue("./models/SEI3R_order_{dly_o}.stmx")
mdl       <- read_xmile(mdl_path)
stocks    <- sd_stocks(mdl)
stan_path <- str_glue("./Stan_files/SEI3R_{dly_o}_smth.stan")
write_SEI3R_model(mdl_path, stan_path)
```

```{r fit_SMTH_1}
stan_d <- list(n_obs    = nrow(irish_data),
               y1       = irish_data$y,
               n_params = 3,
               n_difeq  = nrow(stocks),
               t0       = 0,
               ts       = 1:nrow(irish_data))

fit_options <- list(stan_d      = stan_d,
                    seed        = 931918239,
                    warmup      = 4000,
                    sampling    = 2000,
                    adapt_delta = 0.90,
                    step_size   = 0.0001) # default

results            <- run_stan_file(dly_o, fit_options, folder, stan_folder)
time_list[[dly_o]] <- calculate_time(results$time)
sf                 <- results$sf
```

```{r, fig.height = 3.5}
plot_traces(sf)
```

```{r}
posterior_df                 <- as.data.frame(sf)
posterior_list[[dly_o]]      <- posterior_df
sim_incidences_list[[dly_o]] <- construct_incidence_df(posterior_df)
Z_list[[dly_o]]              <- extract_timeseries_stock("Z", posterior_df,
                                                         stocks, "o")
ll_list[[dly_o]]             <- posterior_df %>% select(log_lik)
```

### 2nd order delay

```{r}
dly_o <- 2 # delay order

mdl_path  <- str_glue("./models/SEI3R_order_{dly_o}.stmx")
mdl       <- read_xmile(mdl_path)
stocks    <- sd_stocks(mdl)
stan_path <- str_glue("./Stan_files/SEI3R_{dly_o}_smth.stan")
write_SEI3R_model(mdl_path, stan_path)
```

```{r fit_SMTH_2}
stan_d <- list(n_obs    = nrow(irish_data),
               y1       = irish_data$y,
               n_params = 3,
               n_difeq  = nrow(stocks),
               t0       = 0,
               ts       = 1:nrow(irish_data))

fit_options <- list(stan_d      = stan_d,
                    seed        = 693132317,
                    warmup      = 2000,
                    sampling    = 2000,
                    adapt_delta = 0.95, # default
                    step_size   = 0.0001) 

results            <- run_stan_file(dly_o, fit_options, folder, stan_folder)
time_list[[dly_o]] <- calculate_time(results$time)
sf                 <- results$sf
```

```{r, fig.height = 3.5}
plot_traces(sf)
```

```{r}
posterior_df                 <- as.data.frame(sf)
posterior_list[[dly_o]]      <- posterior_df
sim_incidences_list[[dly_o]] <- construct_incidence_df(posterior_df)
Z_list[[dly_o]]              <- extract_timeseries_stock("Z", posterior_df,
                                                         stocks, "o")
ll_list[[dly_o]]             <- posterior_df %>% select(log_lik)
```

### 3rd order delay

```{r}
dly_o <- 3 # delay order

mdl_path  <- str_glue("./models/SEI3R_order_{dly_o}.stmx")
mdl       <- read_xmile(mdl_path)
stocks    <- sd_stocks(mdl)
stan_path <- "./Stan_files/SEI3R_3_smth.stan"
write_SEI3R_model(mdl_path, stan_path)
```

```{r fit_SMTH_3}
stan_d <- list(n_obs    = nrow(irish_data),
               y1       = irish_data$y,
               n_params = 3,
               n_difeq  = nrow(stocks),
               t0       = 0,
               ts       = 1:nrow(irish_data))

fit_options <- list(stan_d      = stan_d,
                    seed        = 477626707,
                    warmup      = 2000,
                    sampling    = 2000,
                    step_size   = 0.0001,
                    adapt_delta = 0.95) # default

results            <- run_stan_file(dly_o, fit_options, folder, stan_folder)
time_list[[dly_o]] <- calculate_time(results$time)
sf                 <- results$sf
```

```{r, fig.height = 3.5}
plot_traces(sf)
```

```{r}
posterior_df                 <- as.data.frame(sf)
posterior_list[[dly_o]]      <- posterior_df
sim_incidences_list[[dly_o]] <- construct_incidence_df(posterior_df)
Z_list[[dly_o]]              <- extract_timeseries_stock("Z", posterior_df,
                                                         stocks, "o")
ll_list[[dly_o]]             <- posterior_df %>% select(log_lik)
```


### 4th order delay

```{r}
dly_o <- 4 # delay order

mdl_path  <- str_glue("./models/SEI3R_order_{dly_o}.stmx")
mdl       <- read_xmile(mdl_path)
stocks    <- sd_stocks(mdl)
stan_path <- str_glue("./Stan_files/SEI3R_{dly_o}_smth.stan")
write_SEI3R_model(mdl_path, stan_path)
```

```{r fit_SMTH_4}
stan_d <- list(n_obs    = nrow(irish_data),
               y1       = irish_data$y,
               n_params = 3,
               n_difeq  = nrow(stocks),
               t0       = 0,
               ts       = 1:nrow(irish_data))

fit_options <- list(stan_d      = stan_d,
                    seed        = 986614638,
                    warmup      = 2000,
                    sampling    = 2000,
                    step_size   = 0.001,
                    adapt_delta = 0.8) # default

results            <- run_stan_file(dly_o, fit_options, folder, stan_folder)
time_list[[dly_o]] <- calculate_time(results$time)
sf                 <- results$sf
```

```{r, fig.height = 3.5}
plot_traces(sf)
```

```{r}
posterior_df                 <- as.data.frame(sf)
posterior_list[[dly_o]]      <- posterior_df
sim_incidences_list[[dly_o]] <- construct_incidence_df(posterior_df)
Z_list[[dly_o]]              <- extract_timeseries_stock("Z", posterior_df,
                                                         stocks, "o")
ll_list[[dly_o]]             <- posterior_df %>% select(log_lik)
```


### 5th order delay

```{r}
dly_o <- 5 # delay order

mdl_path  <- str_glue("./models/SEI3R_order_{dly_o}.stmx")
mdl       <- read_xmile(mdl_path)
stocks    <- sd_stocks(mdl)
stan_path <- str_glue("./Stan_files/SEI3R_{dly_o}_smth.stan")
write_SEI3R_model(mdl_path, stan_path)
```

```{r fit_SMTH_5}
stan_d <- list(n_obs    = nrow(irish_data),
               y1       = irish_data$y,
               n_params = 3,
               n_difeq  = nrow(stocks),
               t0       = 0,
               ts       = 1:nrow(irish_data))

fit_options <- list(stan_d      = stan_d,
                    seed        = 549943389,
                    warmup      = 2000,
                    sampling    = 2000,
                    step_size   = 0.001,
                    adapt_delta = 0.8) # default

results            <- run_stan_file(dly_o, fit_options, folder, stan_folder)
time_list[[dly_o]] <- calculate_time(results$time)
sf                 <- results$sf
```

```{r, fig.height = 3.5}
plot_traces(sf)
```

```{r}
posterior_df                 <- as.data.frame(sf)
posterior_list[[dly_o]]      <- posterior_df
sim_incidences_list[[dly_o]] <- construct_incidence_df(posterior_df)
Z_list[[dly_o]]              <- extract_timeseries_stock("Z", posterior_df,
                                                         stocks, "o")
S_df                         <- extract_timeseries_stock("S", posterior_df,
                                                         stocks, "o")
ll_list[[dly_o]]             <- posterior_df %>% select(log_lik)
```


### 6th order delay

```{r}
dly_o <- 6 # delay order

mdl_path  <- str_glue("./models/SEI3R_order_{dly_o}.stmx")
mdl       <- read_xmile(mdl_path)
stocks    <- sd_stocks(mdl)
stan_path <- str_glue("./Stan_files/SEI3R_{dly_o}_smth.stan")
write_SEI3R_model(mdl_path, stan_path)
```

```{r fit_SMTH_6}
stan_d <- list(n_obs    = nrow(irish_data),
               y1       = irish_data$y,
               n_params = 3,
               n_difeq  = nrow(stocks),
               t0       = 0,
               ts       = 1:nrow(irish_data))

fit_options <- list(stan_d      = stan_d,
                    seed        = 846206826,
                    warmup      = 2000,
                    sampling    = 2000,
                    adapt_delta = 0.90, # default
                    step_size   = 0.001) 

results            <- run_stan_file(dly_o, fit_options, folder, stan_folder)
time_list[[dly_o]] <- calculate_time(results$time)
sf                 <- results$sf
```

```{r, fig.height = 3.5}
plot_traces(sf)
```

```{r}
posterior_df                 <- as.data.frame(sf)
posterior_list[[dly_o]]      <- posterior_df
sim_incidences_list[[dly_o]] <- construct_incidence_df(posterior_df)
Z_list[[dly_o]]              <- extract_timeseries_stock("Z", posterior_df,
                                                         stocks, "o")
ll_list[[dly_o]]             <- posterior_df %>% select(log_lik)
```

### 7th order delay

```{r}
dly_o <- 7 # delay order

mdl_path  <- str_glue("./models/SEI3R_order_{dly_o}.stmx")
mdl       <- read_xmile(mdl_path)
stocks    <- sd_stocks(mdl)
stan_path <- str_glue("./Stan_files/SEI3R_{dly_o}_smth.stan")
write_SEI3R_model(mdl_path, stan_path)
```

```{r fit_SMTH_7}
stan_d <- list(n_obs    = nrow(irish_data),
               y1       = irish_data$y,
               n_params = 3,
               n_difeq  = nrow(stocks),
               t0       = 0,
               ts       = 1:nrow(irish_data))

fit_options <- list(stan_d      = stan_d,
                    seed        = 373573480,
                    warmup      = 2000,
                    sampling    = 2000,
                    adapt_delta = 0.95, # default
                    step_size   = 0.0001) 

results            <- run_stan_file(dly_o, fit_options, folder, stan_folder)
time_list[[dly_o]] <- calculate_time(results$time)
sf                 <- results$sf
```

```{r, fig.height = 3.5}
plot_traces(sf)
```

```{r}
posterior_df                 <- as.data.frame(sf)
posterior_list[[dly_o]]      <- posterior_df
sim_incidences_list[[dly_o]] <- construct_incidence_df(posterior_df)
Z_list[[dly_o]]              <- extract_timeseries_stock("Z", posterior_df,
                                                         stocks, "o")
ll_list[[dly_o]]             <- posterior_df %>% select(log_lik)
```

### 8th order delay

```{r}
dly_o <- 8 # delay order

mdl_path  <- str_glue("./models/SEI3R_order_{dly_o}.stmx")
mdl       <- read_xmile(mdl_path)
stocks    <- sd_stocks(mdl)
stan_path <- str_glue("./Stan_files/SEI3R_{dly_o}_smth.stan")
write_SEI3R_model(mdl_path, stan_path)
```

```{r fit_SMTH_8}
stan_d <- list(n_obs    = nrow(irish_data),
               y1       = irish_data$y,
               n_params = 3,
               n_difeq  = nrow(stocks),
               t0       = 0,
               ts       = 1:nrow(irish_data))

fit_options <- list(stan_d      = stan_d,
                    seed        = 107900538,
                    warmup      = 4000,
                    sampling    = 2000,
                    adapt_delta = 0.80, # default
                    step_size   = 0.001) 

results            <- run_stan_file(dly_o, fit_options, folder, stan_folder)
time_list[[dly_o]] <- calculate_time(results$time)
sf                 <- results$sf
```

```{r, fig.height = 3.5}
plot_traces(sf)
```

```{r}
posterior_df                 <- as.data.frame(sf)
posterior_list[[dly_o]]      <- posterior_df
sim_incidences_list[[dly_o]] <- construct_incidence_df(posterior_df)
Z_list[[dly_o]]              <- extract_timeseries_stock("Z", posterior_df,
                                                         stocks, "o")
ll_list[[dly_o]]             <- posterior_df %>% select(log_lik)
```

### 9th order delay

```{r}
dly_o <- 9 # delay order

mdl_path  <- str_glue("./models/SEI3R_order_{dly_o}.stmx")
mdl       <- read_xmile(mdl_path)
stocks    <- sd_stocks(mdl)
stan_path <- str_glue("./Stan_files/SEI3R_{dly_o}_smth.stan")
write_SEI3R_model(mdl_path, stan_path)
```

```{r fit_SMTH_9}
stan_d <- list(n_obs    = nrow(irish_data),
               y1       = irish_data$y,
               n_params = 3,
               n_difeq  = nrow(stocks),
               t0       = 0,
               ts       = 1:nrow(irish_data))

fit_options <- list(stan_d      = stan_d,
                    seed        = 790975884,
                    warmup      = 4000,
                    sampling    = 2000,
                    adapt_delta = 0.80, # default
                    step_size   = 0.001) 

results            <- run_stan_file(dly_o, fit_options, folder, stan_folder)
time_list[[dly_o]] <- calculate_time(results$time)
sf                 <- results$sf
```

```{r, fig.height = 3.5}
plot_traces(sf)
```

```{r}
posterior_df                 <- as.data.frame(sf)
posterior_list[[dly_o]]      <- posterior_df
sim_incidences_list[[dly_o]] <- construct_incidence_df(posterior_df)
Z_list[[dly_o]]              <- extract_timeseries_stock("Z", posterior_df,
                                                         stocks, "o")
ll_list[[dly_o]]             <- posterior_df %>% select(log_lik)
```


\newpage

## Expected values

###  Predicted incidence compared to daily case counts

\hfill

```{r inc_fits_g, fig.height = 7}

set.seed(19860618)
incidence_g <- purrr::map(sim_incidences_list, function(df) {
  
  order <- unique(df$order)
  
  sample_iters <- sample.int(8000, 100)
  
  df <- df %>% filter(iter %in% sample_iters)
  
  ggplot(df, aes(x = time, y = value)) +
  geom_line(aes(group = iter), colour = STH_colour, alpha = 0.1) +
  geom_point(data = irish_data, aes(y = y), colour = data_colour,
             alpha = 0.8, size = 0.5, shape = 16) +
  theme_pubr() +
  labs(subtitle = str_glue("Order: {order}"),
       x = "", 
       y = parse(text = "C[t]^d")) +
  theme(axis.text = element_text(colour = "grey60", size = 8),
        axis.line  = element_line(colour = "grey60"),
        axis.ticks = element_line(colour = "grey60"),
        axis.title = element_text(colour = "grey40"))
}) %>% compact()

(incidence_g[[1]] + incidence_g[[2]] + incidence_g[[3]]) / 
  ( incidence_g[[4]] + incidence_g[[5]] + incidence_g[[6]]) /
  (incidence_g[[7]] + incidence_g[[8]] + incidence_g[[9]]) +
  plot_annotation(caption = "Time since the first reported case [Days]",
                  theme = theme(plot.caption = element_text(hjust = 0.5)))

```


```{r, fig.height = 7}
set.seed(19860618)

map_df(sim_incidences_list, function(df) {
    sample_iters <- sample.int(8000, 100)
    df <- df %>% filter(iter %in% sample_iters)
}) -> sample_incidences

imap_dfr(Z_list, function(df, i) {
  sample_iters <- sample.int(8000, 100)
  df           <- df %>% filter(iter %in% sample_iters) %>% 
    mutate(order = i)
}) -> sample_Z

df_labels <- data.frame(x = 6, y = 750, 
                        label = str_glue("Order: {1:9}"),
                        order = 1:9)
y_lab <- "C[t]^d"
x_lab <- "Time since the first reported case [Days]"
g1 <- plot_fits_by_order(sample_incidences, irish_data, df_labels, 18, x_lab,
                         y_lab = y_lab)


actual_data <- rename(drv_data_obj$df, y = y2)
df_labels   <- df_labels %>% mutate(x = 75, y = 0.85)
y_lab       <- "Z[t]"
x_lab       <- "Time since the first reported case [Days]"
g2          <- plot_fits_by_order(sample_Z, actual_data, df_labels, 16,
                                  x_lab, y_lab)

ggsave("./paper_plots/Fig_06_GSB.pdf", 
       plot = g1 + g2, height = 7, width = 5)
```


\newpage

### Predicted relative contact rate compared to mobility indexes

\hfill

```{r mob_fits_g, fig.height = 7}
mobility_g <- imap(Z_list, function(df, i) {
  
  sample_iters <- sample.int(8000, 100)
  df           <- df %>% filter(iter %in% sample_iters)
  
  ggplot(df, aes(x = time, y = value)) +
  geom_line(aes(group = iter), colour = STH_colour, alpha = 0.1) +
  theme_pubr() +
  geom_point(data = drv_data_obj$df, aes(y = y2), colour = data_colour, 
             alpha = 0.8, size = 0.5) +
  labs(subtitle = str_glue("Order: {i}"),
       x = "", y = parse(text = "Z[t]")) +
  theme(axis.text = element_text(colour = "grey60", size = 8),
        axis.line  = element_line(colour = "grey60"),
        axis.ticks = element_line(colour = "grey60"),
        axis.title = element_text(colour = "grey40")) 
}) %>% compact()

(mobility_g[[1]] + mobility_g[[2]] + mobility_g[[3]]) / (mobility_g[[4]] + mobility_g[[5]] + mobility_g[[6]]) /
  (mobility_g[[7]] + mobility_g[[8]] + mobility_g[[9]]) +
  plot_annotation(caption = "Time since the first reported case [Days]",
                  theme = theme(plot.caption = element_text(hjust = 0.5)))
```


\newpage

### Accuracy

To measure the accuracy of the predicted values, we calculate the Mean absolute 
scale error (MASE) for each trajectory (incidence and relative
transmission rate) generated from the sampling procedure. Incidence trajectories
are compared to daily case counts; whereas relative transmission rates are 
contrasted to mobility indexes. We present the results graphically (violin 
plots) and numerically (tables). Dotted lines in the plots indicate the 
performance threshold (1). Values below the unity indicate good performance.

```{r}
mase_inc <- imap_dfr(sim_incidences_list, mase_per_iter, 
                     data_vector = irish_data$y)

summary_mase <- mase_inc %>% group_by(order) %>% 
  summarise(mean   = mean(mase),
            q_val  = quantile(mase, c(0.025, 0.25, 0.5, 0.75, 0.975)),
            q_type = c("q2.5", "q25", "q50", "q75", "q97.5")) %>% 
  ungroup()

ggplot(mase_inc, aes(x = order, y = mase)) +
  geom_violin(aes(group = order), colour = STH_colour) +
  scale_x_continuous(breaks = 1:9) +
  scale_y_continuous(limits = c(0.95, 1.01)) +
  stat_smooth(data = summary_mase, aes(x = order, y = mean),
              geom = 'line', alpha = 0.25, se = FALSE, 
              colour = STH_colour, size = 0.5, linetype = "dashed") +
  geom_hline(yintercept = 1, linetype = "dotted", colour = "grey50") +
  theme_pubr() +
  labs(subtitle = "Incidence prediction accuracy",
       y = "MASE [Unitless]",
       x = "Delay order")
```

```{r}
wide_smy_mase <- summary_mase %>% 
  mutate(q_val = round(q_val, 3),
         mean  = round(mean, 3)) %>% 
  pivot_wider(names_from = q_type, values_from = q_val)

knitr::kable(wide_smy_mase, "latex", booktabs = TRUE)
```


```{r, fig.height = 3.5}
mase_mob <- imap_dfr(Z_list, mase_per_iter, 
                     data_vector = drv_data_obj$df$y2)

summary_mase_mob <- mase_mob %>% group_by(order) %>% 
  summarise(mean   = mean(mase),
            q_val  = quantile(mase, c(0.025, 0.25, 0.5, 0.75, 0.975)),
            q_type = c("q2.5", "q25", "q50", "q75", "q97.5")) %>% 
  ungroup()

ggplot(mase_mob, aes(x = order, y = mase)) +
  geom_violin(aes(group = order), colour = STH_colour) +
  scale_x_continuous(breaks = 1:9) +
  stat_smooth(data = summary_mase_mob, aes(x = order, y = mean),
              geom = 'line', alpha = 0.5, se = FALSE, 
              colour = STH_colour, size = 0.5, linetype = "dashed") +
  geom_hline(yintercept = 1, linetype = "dotted", colour = "grey50") +
  theme_pubr() +
  labs(subtitle = "Accuracy of the predicted transmission rate",
       x        = "Delay order",
       y        = "MASE [Unitless]")
```


```{r}
wide_smy_mob <- summary_mase_mob %>% 
  mutate(q_val = round(q_val, 3),
         mean  = round(mean, 3)) %>% 
  pivot_wider(names_from = q_type, values_from = q_val)

knitr::kable(wide_smy_mob, "latex", booktabs = TRUE)
```

\newpage

## Posterior distribution

In this section, we summarise (graphically and numerically) the parameter 
samples obtained from the HMC algorithm.

```{r, fig.height = 5}
source("./R_scripts/R_estimates.R")

imap_dfr(posterior_list, function(df, i) {
  
  df %>% select(zeta, P_0, nu, upsilon) %>% 
    mutate(R_0 = estimate_r(zeta), iter = row_number(), order = i) %>% 
    pivot_longer(c(-iter, -order))
}) -> tidy_pars_df


ggplot(tidy_pars_df, aes(x = as.factor(order), y = value)) +
  geom_violin(aes(group = order), colour = STH_colour) +
  facet_wrap(~name, scales = "free", labeller = label_parsed) +
  labs(x = "Delay order", y = "Value") +
  theme_pubr()
```

```{r estimate_summary_t}

format_estimate <- function(mean, quantiles) {
  m  <- str_pad(round(mean, 2), 4,  "right", 0)
  ll <- str_pad(round(quantiles[[1]], 2), 4,  "right", 0)
  ul <- str_pad(round(quantiles[[2]], 2), 4,  "right", 0)
  
  str_glue("{m} [{ll}-{ul}]")
}
tidy_pars_df %>% group_by(order, name) %>% 
  summarise(estimate = format_estimate(mean(value), 
                                       quantile(value, c(0.025, 0.975)))) %>% 
  pivot_wider(names_from = name, values_from = estimate) %>% 
  select(order, R_0, zeta, P_0, nu, upsilon)-> summary_est

colnames(summary_est) <- c("Order", "R(0)", "$\\zeta$", "P(0)", "$\\nu$", "$\\upsilon$")

knitr::kable(summary_est, "latex", booktabs = TRUE, escape = FALSE)
```

\newpage

# Prediction of hidden states

Based on the results above, we select the 4th-order information delay structure
as DGP3's process model to predict latent states.

\hfill

```{r}
inc_df <- sim_incidences_list[[5]] %>% select(-order, -variable)

wkl_inc <- irish_data %>% slice(1:77)%>%
  mutate(week = ((time - 1) %/% 7) + 1) %>% 
  group_by(week) %>% summarise(y = sum(y)) %>% 
  mutate(time = week * 7)

wkl_df <- inc_df %>% filter(time <= 77) %>% 
  mutate(week = ((time - 1) %/% 7) + 1) %>% 
  group_by(iter, week) %>% 
  summarise(value = sum(value))

qs <- c(0.025, 0.25, 0.5, 0.75, 0.975)

pred_inc <- wkl_df %>% group_by(week) %>% 
  summarise(median = median(value), vals = quantile(value, qs),
            lims = c("q2.5", "q25", "q50", "q75", "q97.5")) %>% 
  pivot_wider(names_from = lims, values_from = vals)

g1 <- plot_wkl_fit(pred_inc, wkl_inc, "C[t]^w", "Incidence fit", 
                   shape = 16, STH_colour)
```

```{r}
actual_mob <- drv_data_obj$df %>% 
  mutate(week = time / 7) %>% 
  rename(y = y2)

mob_df <- Z_list[[5]] %>% select(-stock) %>% 
  mutate(week = time / 7)

qs <- c(0.025, 0.25, 0.5, 0.75, 0.975)

summary_mob <- mob_df %>% group_by(week) %>% 
  summarise(median = median(value), vals = quantile(value, qs),
            lims = c("q2.5", "q25", "q50", "q75", "q97.5")) %>% 
  pivot_wider(names_from = lims, values_from = vals)

g2 <- plot_wkl_fit(summary_mob, actual_mob, "Z[t]", "Mobility fit", 
                   18, STH_colour)
```

```{r}
source("./R_scripts/R_estimates.R")
pst_df <- posterior_list[[4]]

zeta_df <- pst_df %>% select(zeta) %>% 
  mutate(iter = row_number())

mob_df %>% rename(Z = value) %>% left_join(zeta_df, by = "iter") %>% 
  mutate(beta = zeta * Z,
         R    = estimate_r(beta)) -> R_df
S_df %>% mutate(s = value / 4937796) -> s_df

bind_cols(R_df[, c("iter", "week", "R")], select(s_df, s)) %>% 
  mutate(Re = R * s) -> Re_df

summary_Re <- Re_df %>% group_by(week) %>% 
    summarise(q50 = median(R), vals = quantile(R, c(0.025, 0.975)),
            lims = c("q2.5", "q97.5")) %>% 
  pivot_wider(names_from = lims, values_from = vals)


ggplot(summary_Re, aes(x = week, y = q50)) +
  geom_hline(yintercept = 1, colour = ET_colour, linetype = "dashed") +
  geom_line(colour = STH_colour) +
  geom_ribbon(alpha = 0.25, aes(ymin = q2.5, ymax = q97.5),
              fill = STH_colour) +
  geom_vline(xintercept = 1.86, colour = "grey50", linetype = "dotted") +
  annotate("text", x = 1.96, y = 6, size = 1.5,
             label = "Delay phase", hjust = 0, size = 3, colour = "grey50") +
  geom_vline(xintercept = 4, colour = "grey50", linetype = "dotted") +
  annotate("text", x = 4.1, y = 6, size = 1.5,
             label = "Stay at home", hjust = 0, size = 3, colour = "grey50") +
  labs(y = parse(text = "Re[t]"), x = "Week",
       title = "Effective reproductive number")+
  scale_x_continuous(breaks = 1:11) +
  theme_pubr()  +
  theme(axis.title = element_text(colour = "grey40"),
        axis.text  = element_text(colour = "grey60"),
        plot.title = element_text(colour = "grey25"),
        axis.ticks = element_line(colour = "grey60"),
        axis.line  = element_line(colour = "grey60"))-> g3
```

```{r, fig.height = 8}
g1 / g2  / g3
```



```{r}

tidy_pars_df %>% filter(order == 5) %>% select(-order) %>% 
  group_by(name) %>% summarise(mean   = mean(value), 
                               vals   = quantile(value, c(0.025, 0.975)),
                               lims   = c("lower_limit", "upper_limit")) %>% 
  pivot_wider(names_from = lims, values_from = vals) -> est_df


results_list <- list(label         = "3 (SM4)",
                     sim_inc       = pred_inc,
                     sim_mob       = summary_mob,
                     Re_t          = summary_Re,
                     estimates_df  = est_df)

fn <- file.path(folder, "predictions.rds")

if(!file.exists(fn)) saveRDS(results_list, fn)
```

# Computational time

```{r}
imap_dfr(time_list, function(time_val, order) {
  data.frame(order = order, time = time_val)
}) -> time_df

tt <- sum(time_df$time) %>% round(0)

plot_time_comparison(time_df, tt)
```


